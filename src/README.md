项目编码过程总结及思考：

第一次：
1. 拿到初始需求后拆分任务后即开始编码。
2. 编码过程中隐隐发现有问题（不到一小时，赶紧停下了），因为我定义了一个Flag对象，专门存放**具体的**标记、类型，以及缺省值。
如我存储了l、l对应的类型boolean，值，甚至默认值。。这看起来和需求相符，但实际上搞错了对象职责。
3. 于是查看《Clean code》一书的原需求描述，并看人家是怎么实现的，这时已经有了大体思路：比如依赖接口而非具体的实现，Schema的定义也清晰了。
4. 小结，搞错对象职责会带来降维伤害！

第二次：
1. 重新捋过思路后，在不看参考代码的情况下进行编码。测试驱动的价值开始体现。
我直接用参数前导符"-"分割不同的参数（而非空格），很大程度上简化了解析步骤。
2. 实现过后，和《Clean Code》中的代码对比，发现一个共同的问题：存在大量的switch语句，
于是使用一个Map专门存放Schema中的类型和对应的解析器，也即Arg.java中的TYPE_PARSER_MAP。需要的时候利用反射机制实例化即可。

第三次：
1. 开始实现扩展需求，支持list类型。由于前面抽象出了解析器，导致这步非常容易。
2. 随后发现，列表中有负数时结果不对，调试后发现原因：负号被当做参数前导符，如"i 1,2,-3,5"被分成了两段，这是错误的，
于是新增方法correctArgWithNegativeNum用于纠正这种情况。
同时补充异常，针对初始需求中的flag p，若端口号为负数，会抛异常。当然，随着需求变化，可以对应调整。

第四次：
1. 优化代码，目前功能已经完成，但是某些函数（尤其是方法correctArgWithNegativeNum），将开始时用的StringBuilder换成了StringJoiner,并在必要的时候引入Stream()以简化代码。




